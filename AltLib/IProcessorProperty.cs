namespace AltLib
{
    /// <summary>
    /// A tagging interface that indicates a property of <see cref="CmdData"/>
    /// that was introduced by an implementation of <see cref="ICmdProcessor"/>.
    /// </summary>
    /// <remarks>
    /// Nothing actually implements this interface, and its use is optional.
    /// It may be used to define a constant that provides the name of a property.
    /// The value of the constant itself is irrelevant (null should suffice).
    /// For example:
    /// <code>
    /// 
    ///   const IProcessorProperty MyProperty = null;
    ///   
    ///   void ICmdProcessor.Process(CmdData data)
    ///   {
    ///       data.Add(nameof(MyProperty), 123);
    ///   }
    ///   
    /// </code>
    /// In some situations, a processor may need to record some aspect of the
    /// processing results that was not known during data entry. Whether this
    /// is a good idea or not is another matter.
    /// <para/>
    /// Letting a processor add extra properties could introduce dependencies
    /// between processors (one processor might expect to consume an extra property
    /// that was generated by a previous processor). However, this assumes that
    /// a command consumed by more than one processor will always be handled in
    /// a predictable, sequential order. And there is a fair chance that 
    /// processors could run in parallel, so some coordination would be required
    /// if there are any processor dependencies.
    /// <para/>
    /// Another potential issue is the fact that if we subsequent merge in
    /// commands from other branches, results determined after that could
    /// have changed.
    /// <para/>
    /// That said, this capability could be useful so long as the pitfalls
    /// are well understood.
    /// </remarks>
    public interface IProcessorProperty
    {
    }
}
